
// Read environment variables from ~/.env
require('dotenv').config()

// Import libraries for different storage backends
const fs = require('fs').promises
const path = process.env.FS_PATH

const mongoose = require('mongoose')
const mongoDBConnectionString = 'mongodb://' + process.env.MONGO_HOST + ':' +
  process.env.MONGO_PORT + '/' + process.env.MONGO_DATABASE

const postgres = require('pg')

const redis = require('redis')
const redisConnectionString = 'redis://' + process.env.REDIS_HOST + ':' +
  process.env.REDIS_PORT

const memjs = require('memjs')
const memCachedConnectionString = process.env.MEM_HOST + ':' +
  process.env.MEM_PORT

// Enum for different types of storage backends that can be used
const STORAGE_TYPES = {
  POSTGRES: 'POSTGRES',
  REDIS: 'REDIS',
  MONGODB: 'MONGODB',
  MEMCACHED: 'MEMCACHED',
  FILE: 'FILE'
}

// Standard behaviour of the backend is:
// - Javascript in and out. So JSON.stringify and JSON.parse is done here.
// - Key is determined by the storage method if possible (like MongoDB and Postgres).
//   If not, a key  must be passed in options.key
// - For Redis and Memcached: key is passed in options.key
// - For file-based storage: filename is determined by the client,
//   passed in options.filename, and returned after storing (like a key)
class StorageBackend {
  constructor (storageType, options) {
    if (storageType) {
      this.setStorageType(storageType, options)
    }
  }

  async configPostgres (tableName) {
    // Initialize connection to Postgres
    const client = new postgres.Client({
      user: process.env.PG_USER,
      host: process.env.PG_HOST,
      database: process.env.PG_DATABASE,
      password: process.env.PG_PASSWORD,
      port: process.env.PG_PORT
    })
    this.postgresClient = client
    this.postgresTableName = tableName
    // Connect to the database
    return new Promise((resolve, reject) => {
      client.connect()
        .then(() => {
          // Call the function to create the table
          createTable(tableName)
          resolve()
        })
        .catch(err => {
          console.error('Error connecting to the database:', err)
          reject(err)
        })
    })

    // Function to create the table
    function createTable (tableName) {
      // We use JSONB (binary JSON format of Postgres) to store objects
      const createTableQuery = `
        CREATE TABLE IF NOT EXISTS ${tableName} (
          id SERIAL PRIMARY KEY,
          data JSONB
        );
      `
      return new Promise((resolve, reject) => {
        client.query(createTableQuery)
          .then(() => {
            resolve()
          })
          .catch(error => {
            reject(error)
          })
      })
    }
  }

  // Sets the storage type. Valid values are POSTGRES, REDIS, MONGODB, MEMCACHED, FILE
  async setStorageType (storageType, options) {
    this.storageType = storageType
    switch (storageType) {
      case STORAGE_TYPES.POSTGRES:
        await this.configPostgres(options.tableName)
        break
      case STORAGE_TYPES.REDIS:
        this.redisClient = await redis.createClient(redisConnectionString)
          .on('error', err => console.log('Redis Client Error', err))
          .connect()
        break
      case STORAGE_TYPES.MONGODB:
        mongoose.connect(mongoDBConnectionString, {})
        // We do not enforce a schema with MongoDB
        this.ObjectModel = mongoose.model('ObjectModel', new mongoose.Schema({},
          { strict: false, versionKey: false }))
        break
      case STORAGE_TYPES.MEMCACHED:
        this.memcached = memjs.Client.create(memCachedConnectionString)
        break
      case STORAGE_TYPES.FILE:
        // No action required for the file system
        break
      default:
        throw new Error('Invalid storage type')
    }
  }

  // Function to insert a JavaScript object by key
  // Returns the id generated by the database
  async postgresInsertObject (object) {
    try {
      const query = `INSERT INTO ${this.postgresTableName} (data) VALUES ($1)  RETURNING id;`
      return await this.postgresClient.query(query, [object])
    } catch (error) {
      console.error('Error inserting object:', error)
    }
  }

  // Function to retrieve a JavaScript object by key
  async postgresGetObjectByKey (key) {
    try {
      const query = `SELECT data FROM ${this.postgresTableName} WHERE id = $1`
      const result = await this.postgresClient.query(query, [key])
      if (result.rows.length > 0) {
        return result.rows[0].data
      } else {
        console.log('No object found with the specified key')
        return null
      }
    } catch (error) {
      console.error('Error retrieving object:', error)
      return null
    }
  }

  // Stores value to the selected storage type.
  async store (object, options) {
    const data = JSON.stringify(object)
    switch (this.storageType) {
      case STORAGE_TYPES.POSTGRES: {
        const result = await this.postgresInsertObject(object)
        if (result.rowCount > 0) {
          return result.rows[0].id
        } else {
          return null
        }
      }
      case STORAGE_TYPES.REDIS:
        await this.redisClient.set(options.key, data)
        return options.key
      case STORAGE_TYPES.MONGODB: {
        // To make sure the payload is stored as a whole and nog merged with the id object
        const objectToStore = { naturalObject: object }
        const storedObject = await this.ObjectModel.create(objectToStore)
        return storedObject._id
      }
      case STORAGE_TYPES.MEMCACHED: {
        const isStored = await this.memcached.set(options.key, data, { expires: 2 })
        return isStored ? options.key : null
      }
      case STORAGE_TYPES.FILE:
        await fs.writeFile(path + options.filename, data)
        return (options.filename)
      default:
        throw new Error('Invalid storage type')
    }
  }

  async retrieve (key, options) {
    switch (this.storageType) {
      case STORAGE_TYPES.POSTGRES:
        return await this.postgresGetObjectByKey(key)
      case STORAGE_TYPES.REDIS:
        return await this.redisClient.get(key)
      case STORAGE_TYPES.MONGODB: {
        const retrievedObject = await this.ObjectModel.findById(key)
        return retrievedObject.naturalObject
      }
      case STORAGE_TYPES.MEMCACHED: {
        const data1 = await this.memcached.get(key)
        return JSON.parse(data1.value.toString())
      }
      case STORAGE_TYPES.FILE: {
        const data = await fs.readFile(path + options.filename, 'utf8')
        return JSON.parse(data)
      }
      default:
        throw new Error('Invalid storage type')
    }
  }
}

module.exports = { StorageBackend, STORAGE_TYPES }
