<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Natural Library Browser Test - Jasmine</title>
    <link rel="stylesheet" href="../../node_modules/jasmine-core/lib/jasmine-core/jasmine.css">
</head>
<body>
    <script>
        // Add error handler to catch loading errors
        window.addEventListener('error', function(e) {
            console.error('Global error:', e.message, e.filename, e.lineno, e.colno);
            if (e.filename && e.filename.includes('natural.js')) {
                document.body.innerHTML = '<div style="color: red; padding: 20px; font-family: monospace;">' +
                    '<h2>Error loading Natural library</h2>' +
                    '<p style="white-space: pre-wrap;">' + e.message + '</p>' +
                    '<p>File: ' + e.filename + ':' + e.lineno + ':' + e.colno + '</p>' +
                    '<p>Please rebuild the browser bundle: npm run build:browser</p>' +
                    '</div>';
                console.log('Error details:', e);
            }
        }, true);
    </script>

    <script src="../../node_modules/jasmine-core/lib/jasmine-core/jasmine.js"></script>
    <script src="../../node_modules/jasmine-core/lib/jasmine-core/jasmine-html.js"></script>
    <script src="../../node_modules/jasmine-core/lib/jasmine-core/boot0.js"></script>

    <script src="../../dist/browser/natural.js"></script>

    <script>
        // Verify natural is loaded
        if (typeof natural === 'undefined') {
            document.body.innerHTML = '<div style="color: red; padding: 20px;">' +
                '<h2>Natural library not loaded</h2>' +
                '<p>The "natural" global object is not defined. Check browser console for errors.</p>' +
                '</div>';
            throw new Error('Natural library failed to load');
        }

        // Load most compiled specs (excluding storage, classifiers, sentiment, analyzers, spellcheck)
        var specFiles = [
            'aggressive_tokenizer_de_spec.js',
            'aggressive_tokenizer_es_spec.js',
            'aggressive_tokenizer_fr_spec.js',
            'aggressive_tokenizer_hi_spec.js',
            'aggressive_tokenizer_nl_spec.js',
            'aggressive_tokenizer_pt_spec.js',
            'aggressive_tokenizer_spec.js',
            'aggressive_tokenizer_sv_spec.js',
            'aggressive_tokenizer_vi_spec.js',
            'brill_pos_tagger_spec.js',
            'brill_pos_trainer_spec.js',
            'carry_stemmer_fr_spec.js',
            'count_inflector_fr_spec.js',
            'count_inflector_spec.js',
            'damerau_levenshtein_spec.js',
            'dice_coefficient_spec.js',
            'double_metaphone_spec.js',
            'hamming_distance_spec.js',
            'jaro-winkler_spec.js',
            'lancaster_stemmer_spec.js',
            'levenshtein_spec.js',
            'longest_path_tree_spec.js',
            'metaphone_spec.js',
            'ngram_spec.js',
            'ngram_zh_spec.js',
            'normalizer_ja_spec.js',
            'normalizer_no_spec.js',
            'normalizer_spec.js',
            'noun_inflector_fr_spec.js',
            'noun_inflector_ja_spec.js',
            'noun_inflector_spec.js',
            'orthography_tokenizer_spec.js',
            'porter_stemmer_de_spec.js',
            'porter_stemmer_es_spec.js',
            'porter_stemmer_fr_spec.js',
            'porter_stemmer_it_spec.js',
            'porter_stemmer_nl_spec.js',
            'porter_stemmer_no_spec.js',
            'porter_stemmer_pt_spec.js',
            'porter_stemmer_ru_spec.js',
            'porter_stemmer_spec.js',
            'porter_stemmer_sv_spec.js',
            'present_verb_inflector_spec.js',
            'remove_diacritics_spec.js',
            'sentence_tokenizer_spec.js',
            'shortest_path_tree_spec.js',
            'soundex_spec.js',
            'stemmer_id_spec.js',
            'stemmer_ja_spec.js',
            'stemmer_token_spec.js',
            'tfidf_spec.js',
            'tokenizer_case_spec.js',
            'tokenizer_ja_spec.js',
            'transliterator_ja_spec.js',
            'treebank_word_tokenizer_spec.js',
            'trie_spec.js',
            'WordPunctTokenizer_spec.js'
        ];

        function createRequire() {
            var cache = {};
            function fetchJsonSync(url) {
                if (cache[url]) {
                    return cache[url];
                }
                var xhr = new XMLHttpRequest();
                xhr.open('GET', url, false);
                xhr.send(null);
                if (xhr.status >= 200 && xhr.status < 300) {
                    cache[url] = JSON.parse(xhr.responseText);
                    return cache[url];
                }
                throw new Error('Failed to load JSON: ' + url + ' (status ' + xhr.status + ')');
            }
            function fetchJsModuleSync(url) {
                if (cache[url]) {
                    return cache[url];
                }
                var xhr = new XMLHttpRequest();
                xhr.open('GET', url, false);
                xhr.send(null);
                if (xhr.status >= 200 && xhr.status < 300) {
                    var module = { exports: {} };
                    var exports = module.exports;
                    var require = createRequire();
                    var wrapped = new Function('require', 'module', 'exports', xhr.responseText + '\n//# sourceURL=' + url);
                    wrapped(require, module, exports);
                    cache[url] = module.exports;
                    return cache[url];
                }
                throw new Error('Failed to load JS module: ' + url + ' (status ' + xhr.status + ')');
            }
            function toPascalCase(value) {
                return value
                    .split(/[_-]/g)
                    .filter(Boolean)
                    .map(function(part) {
                        return part.charAt(0).toUpperCase() + part.slice(1);
                    })
                    .join('');
            }
            function mapNaturalModule(id) {
                var subpath = id.slice('lib/natural/'.length);
                var baseName = subpath.split('/').pop();
                var pascal = toPascalCase(baseName);
                var module = {};

                if (window.natural[pascal]) {
                    module[pascal] = window.natural[pascal];
                }

                var searchName = pascal + 'Search';
                if (window.natural[searchName]) {
                    module[searchName] = window.natural[searchName];
                }

                if (Object.keys(module).length > 0) {
                    return module;
                }

                return window.natural;
            }
            return function(id) {
                if (id === 'lib/natural') {
                    return window.natural;
                }
                if (id.startsWith('lib/natural/')) {
                    return mapNaturalModule(id);
                }
                if (id.endsWith('.json')) {
                    var cleaned = id.replace(/^\.\//, '');
                    var url = '../../spec/' + cleaned;
                    return fetchJsonSync(url);
                }
                if (id.endsWith('.js')) {
                    var cleanedJs = id.replace(/^\.\//, '');
                    var urlJs = '../../spec/' + cleanedJs;
                    return fetchJsModuleSync(urlJs);
                }
                throw new Error('Unsupported require: ' + id);
            };
        }

        function loadSpec(url) {
            return fetch(url)
                .then(function(response) {
                    if (!response.ok) {
                        throw new Error('Failed to load ' + url + ': ' + response.status);
                    }
                    return response.text();
                })
                .then(function(code) {
                    var module = { exports: {} };
                    var exports = module.exports;
                    var require = createRequire();
                    var wrapped = new Function('require', 'module', 'exports', code + '\n//# sourceURL=' + url);
                    wrapped(require, module, exports);
                });
        }

        function loadSpecsSequentially(list, index) {
            if (index >= list.length) {
                return Promise.resolve();
            }
            var url = '../../dist/cjs/spec/' + list[index];
            return loadSpec(url).then(function() {
                return loadSpecsSequentially(list, index + 1);
            });
        }

        // Store results for automation and start Jasmine after specs load
        var jasmineEnv = jasmine.getEnv();
        jasmineEnv.addReporter({
            jasmineDone: function(result) {
                var jsApiReporter = jasmineEnv.reporters && jasmineEnv.reporters.jsApiReporter;

                if (jsApiReporter) {
                    var allSpecs = jsApiReporter.specs();
                    var failed = allSpecs.filter(function(s) { return s.status === 'failed'; });

                    window.testResults = {
                        passed: allSpecs.length - failed.length,
                        failed: failed.length,
                        total: allSpecs.length,
                        results: allSpecs,
                        overallStatus: result.overallStatus
                    };
                }
            }
        });

        loadSpecsSequentially(specFiles, 0)
            .then(function() {
                jasmineEnv.execute();
            })
            .catch(function(error) {
                console.error('Failed to load specs:', error);
                throw error;
            });
    </script>
</body>
</html>
